These are the variables from  my main

  // ----------------------------------------------------------
  // 🧩 Local State
  // ----------------------------------------------------------
  const [isDrawerOpen, setIsDrawerOpen] = useState(false);
  const [editingClient, setEditingClient] = useState(null);

  const [confirmOpen, setConfirmOpen] = useState(false);
  const [confirmAction, setConfirmAction] = useState(null);
  const [confirmMessage, setConfirmMessage] = useState("");

  const [sendOpen, setSendOpen] = useState(false);
  const [sendClientIds, setSendClientIds] = useState([]);

  const [fabOpen, setFabOpen] = useState(false);

  const [searchTerm, setSearchTerm] = useState("");
  const [statusFilters, setStatusFilters] = useState({
    UP: false,
    DOWN: false,
    UNKNOWN: false,
    UNPAID: false,
    LIMITED: false,
    CUTOFF: false,
  });

  const [selectedIds, setSelectedIds] = useState([]);
  const [allSelected, setAllSelected] = useState(false);

  const [currentPage, setCurrentPage] = useState(1);
  const pageSize = 10;

  // ----------------------------------------------------------
  // ⚙️ RTK Query Hooks
  // ----------------------------------------------------------
  const { data: clients = [], isLoading, refetch } = useGetClientsQuery();
  const [addClient] = useAddClientMutation();
  const [updateClient] = useUpdateClientMutation();
  const [deleteClient] = useDeleteClientMutation();
  const [deleteClients] = useDeleteClientsMutation();
  const [sendToClients] = useSendToClientsMutation();
  const [syncClients, { isLoading: isSyncing }] = useSyncClientsMutation();
  const [setPaidBulk] = useSetPaidBulkMutation();
  const [setPaid] = useSetPaidMutation();
  const [setUnpaidBulk] = useSetUnpaidBulkMutation();
  const [setUnpaid] = useSetUnpaidMutation();

  // ----------------------------------------------------------
  // 🧠 Utilities & Helpers
  // ----------------------------------------------------------
  const { showToast, Toast } = InfoDialog();
  const dispatch = useDispatch();
  useWebSocketManager({ showToast, dispatch, refetch });

  // ----------------------------------------------------------
  // 📊 Derived Data (Counts)
  // ----------------------------------------------------------
  const upCount = clients.filter((c) => c.state === "UP").length;
  const downCount = clients.filter((c) => c.state === "DOWN").length;
  const unknownCombinedCount = clients.filter((c) => {
    const isStateUnknown = !["UP", "DOWN"].includes(c.state);
    const isBillingUnknown = !c.billing_date;
    // Match the same logic as your UNKNOWN filter
    return isStateUnknown || isBillingUnknown;
  }).length;

  const unpaidCount = clients.filter((c) => c.status === "UNPAID").length;
  const limitedCount = clients.filter((c) => c.status === "LIMITED").length;
  const cutoffCount = clients.filter((c) => c.status === "CUTOFF").length;

  // ----------------------------------------------------------
  // 🔍 Filtering & Search
  // ----------------------------------------------------------
  useEffect(() => {
    setCurrentPage(1);
  }, [searchTerm]);

  const toggleFilter = (key) => {
    setStatusFilters((prev) => ({
      ...prev,
      [key]: !prev[key],
    }));
  };

  const handleSearch = (value) => {
    setSearchTerm(value);
    setCurrentPage(1);
  };

  const filteredClients = useMemo(() => {
    let result = clients;

    if (searchTerm) {
      const terms = searchTerm
        .split(",")
        .map((t) => t.trim().toLowerCase())
        .filter((t) => t.length > 0);

      // 🔍 Determine which terms match existing group names
      const groupTerms = terms.filter((term) =>
        clients.some((c) => c.group_name?.toLowerCase() === term)
      );
      const otherTerms = terms.filter((term) => !groupTerms.includes(term));

      result = result.filter((c) => {
        const id = c.id?.toString().toLowerCase() || "";
        const name = c.name?.toLowerCase() || "";
        const messenger_id = c.messenger_id?.toLowerCase() || "";
        const group_name = c.group_name?.toLowerCase() || "";
        const connection_name = c.connection_name?.toLowerCase() || "";
        const state = c.state?.toLowerCase() || "";
        const status = c.status?.toLowerCase() || "";

        // ✅ CASE 1: If there are group terms, restrict to those groups
        if (groupTerms.length > 0) {
          if (!groupTerms.includes(group_name)) return false; // skip non-matching groups

          // Within those groups, match any other term (partial)
          if (otherTerms.length === 0) return true; // only group filter given

          return otherTerms.some(
            (term) =>
              id.includes(term) ||
              name.includes(term) ||
              messenger_id.includes(term) ||
              connection_name.includes(term) ||
              state.includes(term) ||
              status.includes(term)
          );
        }

        // ✅ CASE 2: No group filter → search across all fields freely
        return terms.some(
          (term) =>
            id.includes(term) ||
            name.includes(term) ||
            messenger_id.includes(term) ||
            connection_name.includes(term) ||
            group_name.includes(term) ||
            state.includes(term) ||
            status.includes(term)
        );
      });
    }

    // ✅ Keep your state/status filter logic
    const activeFilters = Object.entries(statusFilters)
      .filter(([_, v]) => v)
      .map(([k]) => k);

    if (activeFilters.length > 0) {
      result = result.filter((c) => {
        const matchState = activeFilters.includes(c.state);
        const matchStatus = activeFilters.includes(c.status);
        const isUnknown =
          activeFilters.includes("UNKNOWN") &&
          (!["UP", "DOWN"].includes(c.state) || !c.billing_date);

        return matchState || matchStatus || isUnknown;
      });
    }

    return result;
  }, [clients, searchTerm, statusFilters]);

  // ----------------------------------------------------------
  // 📄 Pagination
  // ----------------------------------------------------------
  const totalPages = Math.ceil(filteredClients.length / pageSize);
  const currentPageSafe = Math.min(currentPage, totalPages || 1);
  const paginatedClients = filteredClients
    .map((c) => ({
      ...c,
      // If there's no billing_date, force status to UNKNOWN
      status: !c.billing_date ? "UNKNOWN" : c.status,
    }))
    .slice((currentPageSafe - 1) * pageSize, currentPageSafe * pageSize);

  useEffect(() => {
    const savedPage = Number(localStorage.getItem("clientsPage")) || 1;
    setCurrentPage(savedPage);
  }, []);

  useEffect(() => {
    localStorage.setItem("clientsPage", currentPage);
  }, [currentPage]);

  // ----------------------------------------------------------
  // ✅ Selection Handlers
  // ----------------------------------------------------------
  const toggleSelection = (id) => {
    setSelectedIds((prev) => {
      const newSelected = prev.includes(id)
        ? prev.filter((x) => x !== id)
        : [...prev, id];

      if (allSelected && !newSelected.includes(id)) {
        setAllSelected(false);
      }

      return newSelected;
    });
  };

  const handleSelectAllPage = (checked, pageClients) => {
    if (checked) {
      const pageIds = pageClients.map((c) => c.id);
      setSelectedIds((prev) => [...new Set([...prev, ...pageIds])]);
    } else {
      const pageIds = pageClients.map((c) => c.id);
      setSelectedIds((prev) => prev.filter((id) => !pageIds.includes(id)));
    }
  };

  const handleSelectAllAcrossPages = () => {
    const allFilteredIds = filteredClients.map((c) => c.id);
    setSelectedIds(allFilteredIds);
    setAllSelected(true);
  };

  const handleSelectAll = () => {
    const allIds = clients.map((c) => c.id);
    setSelectedIds(allIds);
    setAllSelected(true);
  };

  const clearAllSelection = () => {
    setSelectedIds([]);
    setAllSelected(false);
  };

  // ----------------------------------------------------------
  // 💾 CRUD Operations
  // ----------------------------------------------------------
  const handleSaveClient = async (clientData) => {
    try {
      if (!clientData.group_name) {
        clientData.group_name = "G1";
      }
      if (!clientData.connection_name) {
        clientData.connection_name = null;
      }

      if (editingClient) {
        await updateClient({ id: editingClient.id, ...clientData }).unwrap();
        showToast("Client updated ✅");
      } else {
        await addClient(clientData).unwrap();
        showToast("Client added ✅");
      }
      setIsDrawerOpen(false);
      setEditingClient(null);
    } catch (err) {
      console.error("Save failed:", err);
      showToast(err?.data?.detail || "Something went wrong ❌", "error");
    }
  };

  const handleDeleteClient = (id) => {
    setConfirmMessage("Are you sure you want to delete this client?");
    setConfirmAction(() => async () => {
      try {
        await deleteClient(id).unwrap();
        showToast("Client deleted ✅");
        return true;
      } catch {
        showToast("Failed to delete ❌", "error");
        return false;
      }
    });
    setConfirmOpen(true);
  };

  const handleBulkDelete = () => {
    if (selectedIds.length === 0) return;
    setConfirmMessage(
      `Are you sure you want to delete ${selectedIds.length} clients?`
    );
    setConfirmAction(() => async () => {
      try {
        await deleteClients(selectedIds).unwrap();
        showToast(`Deleted ${selectedIds.length} clients ✅`);
        clearAllSelection();
        return true;
      } catch {
        showToast("Failed to delete ❌", "error");
        return false;
      }
    });
    setConfirmOpen(true);
  };

  // ----------------------------------------------------------
  // 💰 Billing Actions
  // ----------------------------------------------------------
  const handleSetPaid = async (id) => {
    try {
      await setPaid([id]).unwrap(); // send single id as array
      showToast("Client marked as PAID ✅");
    } catch {
      showToast("Failed to set paid ❌", "error");
    }
  };

  const handleBulkSetPaid = async () => {
    if (selectedIds.length === 0) return;
    try {
      await setPaidBulk(selectedIds).unwrap();
      showToast(`✅ Set ${selectedIds.length} clients to PAID`);
      clearAllSelection();
    } catch {
      showToast("❌ Failed to update billing status", "error");
    }
  };

  const handleSetUnpaid = async (id) => {
    try {
      await setUnpaid([id]).unwrap(); // single id as array
      showToast("Client marked as UNPAID ❌");
    } catch {
      showToast("Failed to set unpaid ❌", "error");
    }
  };

  const handleBulkSetUnpaid = async () => {
    if (selectedIds.length === 0) return;
    try {
      await setUnpaidBulk(selectedIds).unwrap();
      showToast(`❌ Set ${selectedIds.length} clients to UNPAID`);
      clearAllSelection();
    } catch {
      showToast("❌ Failed to update billing status", "error");
    }
  };
  // ----------------------------------------------------------
  // ✉️ Messaging
  // ----------------------------------------------------------
  const handleOpenSend = () => {
    if (selectedIds.length === 0) return;
    setSendClientIds(selectedIds);
    setSendOpen(true);
  };

  const handleSend = async (templateId) => {
    try {
      const numericIds = sendClientIds.map((id) => Number(id));
      await sendToClients({
        template_id: templateId,
        client_ids: numericIds,
      }).unwrap();

      showToast("Messages sent successfully!");
      setSendOpen(false);
      setSendClientIds([]);
    } catch (error) {
      console.error("Send error:", error);
      showToast("Failed to send messages", "error");
    }
  };

  // ----------------------------------------------------------
  // 🔄 Sync
  // ----------------------------------------------------------
  const handleSyncClients = async () => {
    try {
      await syncClients().unwrap();
      showToast("✅ Clients synced successfully");
    } catch {
      showToast("❌ Failed to sync clients", "error");
    }
  };

  // ✅ Helper: Format date safely
  const formatDate = (dateString) => {
    if (!dateString) return "N/A";
    const d = new Date(dateString);
    if (isNaN(d.getTime())) return "N/A";
    return d.toISOString().split("T")[0]; // YYYY-MM-DD
  };

  // ----------------------------------------------------------
  // 🖼️ Render
  // ----------------------------------------------------------
  const renderStatus = (state) => {
    if (state === "UP") {
      return (
        <div className="flex items-center gap-1">
          <span className="w-2.5 h-2.5 rounded-full bg-green-500 animate-pulse"></span>
          <span className="px-2 py-0.5 rounded-full text-xs font-semibold bg-green-100 text-green-700">
            UP
          </span>
        </div>
      );
    }
    if (state === "DOWN") {
      return (
        <div className="flex items-center gap-1">
          <span className="w-2.5 h-2.5 rounded-full bg-red-500 animate-pulse"></span>
          <span className="px-2 py-0.5 rounded-full text-xs font-semibold bg-red-100 text-red-700">
            DOWN
          </span>
        </div>
      );
    }
    return (
      <div className="flex items-center gap-1">
        <span className="w-2.5 h-2.5 rounded-full bg-gray-400"></span>
        <span className="px-2 py-0.5 rounded-full text-xs font-semibold bg-gray-100 text-gray-700">
          UNKNOWN
        </span>
      </div>
    );
  };

  // 🎨 Render billing status badges (PAID, UNPAID, LIMITED, CUTOFF)
  const renderBillingStatus = (status) => {
    const base =
      "px-2 py-1 text-xs font-semibold rounded-full flex items-center gap-1 w-fit";

    switch (status) {
      case "PAID":
        return (
          <span className={`${base} bg-green-100 text-green-700`}>
            <span className="w-2 h-2 bg-green-500 rounded-full"></span>
            PAID
          </span>
        );
      case "UNPAID":
        return (
          <span className={`${base} bg-yellow-100 text-yellow-700`}>
            <span className="w-2 h-2 bg-yellow-400 rounded-full"></span>
            UNPAID
          </span>
        );
      case "LIMITED":
        return (
          <span className={`${base} bg-orange-100 text-orange-700`}>
            <span className="w-2 h-2 bg-orange-400 rounded-full"></span>
            LIMITED
          </span>
        );
      case "CUTOFF":
        return (
          <span className={`${base} bg-red-200 text-red-800`}>
            <span className="w-2 h-2 bg-red-600 rounded-full"></span>
            CUTOFF
          </span>
        );
      default:
        return (
          <span className={`${base} bg-gray-100 text-gray-700`}>
            <span className="w-2 h-2 bg-gray-400 rounded-full"></span>
            UNKNOWN
          </span>
        );
    }
  };